# Make 24
#### Video Demo:  <https://youtu.be/TSU0XUjhFhQ>
#### Description:

Make 24 is a digital version of the classic “Make 24” poker card game made by Godot 4.3, where players use addition, subtraction, multiplication, and division to manipulate four cards and calculate the result to equal 24. I spent lot of time playing this game during my childhood, but I had never played it as a video game. That’s why I decided to try creating one myself.  The project includes draggable and closable windows, simulating a Macintosh System 7-style desktop environment where players interact with different components of the game. It features two gameplay modes: Normal Mode and Limited Time Mode. In Normal Mode, players can take their time to perform calculations, while Limited Time Mode challenges players to make as many 24s as possible within two minutes. The game also records and compares high scores for the timed mode.

The project is organized into several folders and files, each serving a specific purpose:

##### Files
**Root Files:**
- export_presets.cfg: Configuration file for exporting the project to various platforms. Automatically generated by Godot.
- project.godot: The primary Godot project file that ties the entire project together. Automatically generated by Godot.

**Assets:**
This folder contains resources used in the game, including fonts, sounds effects, sprites, shaders and background images.

**Scenes:**
Each `.tscn` file represents a distinct **scene** of the game:

- start_menu.tscn: The main menu where players can start a new game or quit the game.
- pause_menu.tscn: The pause menu allows players to pause or quit the game by pressing esc key at any point during gameplay.
- desktop.tscn: Simulates the Macintosh System 7 desktop environment(background and icon), where the game is played.
- custom_window.tscn: Provides draggable, closable windows that display contents.
- make24.tscn: The main scene for the gameplay itself. This scene includes:
	- A card container displaying the four cards (imported from card.tscn) drawn from the deck.
	- Labels for instructions and displaying the calculation process in real time, and a count down timer in limited time mode.
	- Buttons for operations (add, subtract, multiply, divide) and an undo button to reverse the last step.
	- Custom animations and sound effects for dealing cards.
- card.tscn: This scene represents an individual card in the game. Each card is a combination of a suit and a number.

**Scripts:**
Scripts add functionality and interactivity to the game’s elements:

The `make_24.gd` implements the core gameplay logic: Manages the game flow, including dealing cards, card operations, player interactions and score system.

0. Game Initialization
`_ready()` function prepares the game UI by disabling buttons and resetting animations.
`prepare_deck()` creates and shuffles a full deck of cards, represented as a list of dictionaries. Each card has a suit and a number which is store in a array to easily considered as fraction, like: `[numerator, denominator]`.

1. Drawing and Updating Cards
`draw_cards(all_cards)` deals four cards from the shuffled deck and populates the card container. Cards are instantiated and made interactive.
`update_upcoming_card()` displays the next card in the deck to the player.
`redraw()` resets the game round by dealing a new set of four cards using `draw_cards`.

2. Card Interaction
`select_card(card)` handles card selection: If no card is selected, it sets the first card as selected. If one card is already selected and an operator is chosen, it calculates the result of the operation and merges the cards.
`calculate(a, b)` performs the selected operation (PLUS, MINUS, MULTIPLY, DIVIDE) on two fractions.
`merge_cards(card1, card2, result)` combines two cards into one using the result of the operation and `make_card` in card.gd. It also saves the game state to the undo stack.
`undo_merge()` reverts the last merge operation by restoring the cards and operation state from the undo stack.

3. Gameplay
`check_24(result)` checks if the player has successfully made 24 with the last operation by checking current visiable card number. If true, it updates the score and flips the 24 card.

4. Game Modes
`_on_limited_time_check_box_toggled(toggled_on)` toggles between Normal and Limited Time modes. It will starts or stops the timer, resets the score for the Limited Time mode.
`_on_timer_timeout()` ends the game when the timer runs out in Limited Time mode. It displays the player’s final score and disables card interactions and resets the UI.
`countdown()` formats the remaining time as MM:SS for display during Limited Time mode.

The other scripts:
- card.gd: Handles card creation (with suit and number inputs by `make_card` function) and interactions. Note that all card numbers are imported as fraction format (e.g., Ace becomes 1/1 and will be imported as array [1,1]). And ensures they are rendered correctly (with poker images or numbers) on the card.
- custom_window.gd: Implements draggable windows using offset variable and close button with `queue_free()`. When closed, it will emit `window_closed` signal to make24.tscn who will remove itself from desktop.
- database.gd: Stores player scores and game state information. It also save and load data with `save_data()` and `load_data()` functions.
- desktop.gd: Manages the desktop interactions between windows.
- main.gd: Handles overall game flow and transitions between scenes, especially overall keyboard input by `func _input(event)` and game's pause mode by `pauseMenu()`.
- pause_menu.gd: Provides functionality for the pause menu buttons: resume and quit.
- start_menu.gd: Handles interactions in the start menu.


**Theme**
`.tres` files in this folder defines the aesthetic and visual design of the game, including fonts, font size, buttons and so on.

##### Design Choices

Instead of rounding decimal results in calculations, I implemented a fraction system to ensure mathematical accuracy and provide a unique challenge. This design required adding custom functions for fraction operations and creating a visual representation of fractions.

Each fraction is stored as a two-element array, where the first element represents the numerator and the second represents the denominator. I also made several custom functions for fraction operations, such as `gcd`, `simplify_fraction` and `format_fraction`. The `gcd` function simplify the resulting fractions by calculating their greatest common divisor (GCD) and can be used to divide both the numerator and denominator by this value. For example, addition combines fractions using the formula `[(a[0]*b[1]) + (b[0]*a[1]), a[1]*b[1]]`, ensuring the result maintains its mathematical integrity. The `format_fraction` will format these fractions as strings, displaying them in a clean and readable format, such as “3/4” or “2” (when the denominator is 1). This system not only avoids rounding errors inherent in floating-point operations but also presents players with a more engaging and precise mathematical challenge.